# 142.环形链表 II

## 问题描述
给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。

**示例 1：**
```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**
```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**
```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

## 解题思路

### 方法一：哈希表
使用哈希表记录已经访问过的节点，遍历链表时，如果发现当前节点已经在哈希表中存在，则说明找到了环的入口节点。

- **优点**：思路简单直观
- **缺点**：需要额外的O(n)空间复杂度

### 方法二：Floyd判圈算法（快慢指针）
这是解决环形链表问题的经典算法，使用两个指针：
1. 快指针 `fast` 每次移动两步
2. 慢指针 `slow` 每次移动一步

- 如果链表中存在环，快指针和慢指针最终会在环内相遇
- 相遇后，将其中一个指针重置到链表头，然后两个指针以相同速度移动，再次相遇的位置就是环的入口

**算法原理**：
设链表头到环入口的距离为 `a`，环入口到相遇点的距离为 `b`，相遇点到环入口的距离为 `c`，则环的长度为 `b + c`。

当快慢指针相遇时：
- 慢指针走过的距离：`a + b`
- 快指针走过的距离：`a + b + n(b + c)`（n为快指针在环内多走的圈数）

由于快指针速度是慢指针的两倍，所以：
`2(a + b) = a + b + n(b + c)`
化简得：`a = (n - 1)(b + c) + c`

这意味着，当快慢指针相遇后，将一个指针重置到链表头，然后两个指针以相同速度移动，它们会在环的入口处相遇。

## 代码实现

<<< ../../../solutions/142_Circular_Linked_List_II.cpp

## 复杂度分析

- **时间复杂度：O(n)**
  - 第一次相遇：慢指针最多走n步，快指针最多走2n步
  - 第二次相遇：两个指针最多走a + c步，而a + c <= n
  - 总时间复杂度为O(n)

- **空间复杂度：O(1)**
  - 只使用了两个指针，没有使用额外的空间
